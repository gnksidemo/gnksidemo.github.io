import{_ as n,W as l,X as r,Y as a,Z as e,$ as o,a1 as t,C as h}from"./framework-a045178c.js";const s={},d=t('<h1 id="data-availability-challenge" tabindex="-1"><a class="header-anchor" href="#data-availability-challenge" aria-hidden="true">#</a> Data Availability Challenge</h1><p>Data availability means the data is correctly stored on storage providers and can be correctly downloaded by users. The challenge module is designed and used to detect whether a data segment/piece is correctly stored on a specified storage provider. For this kind of challenge, there will be three steps:</p><ol><li>Each validator asks the challenged SP for this data piece and the local manifest of the object, if the validator can&#39;t get the expected piece, the piece should be regarded as unavailable.</li><li>Compute the hash of the local manifest, and compare with the related global manifest that recorded in the metadata of the object, once they are different, the piece should be regarded as unavailable.</li><li>Compute the hash of the challenged data piece, compare it with the related data that recorded in the local manifest, once they are different, the piece should be regarded as unavailable.</li></ol><p>The validator collects challenge signatures, if there are more than 2/3 validators voted the same result for the current challenge, the validator will aggregate these signatures and assemble a data challenge attestation, submit this attestation on-chain through a transaction, the first one submits the attestation can get reward, the later transaction which submits the attestation won&#39;t pass the verification. Only the validators whose votes wrapped into the attestation will be rewarded, so it may be that some validators voted, but their votes were not assembled, they won&#39;t get reward for this data availability challenge.</p><h2 id="workflow" tabindex="-1"><a class="header-anchor" href="#workflow" aria-hidden="true">#</a> Workflow</h2><p>The data availability challenge workflow is as below:</p><ol><li>Anyone can submit a transaction to challenge data availability, the challenge information would be recorded on-chain temporarily, and also would be written into the typed event after the transaction has been executed.</li><li>By default, at the end block phase of each block, we will use a random algorithm to generate some data availability challenge typed events. All challenge information will be persisted in storage until it has been confirmed or expired.</li><li>The off-chain data availability detect module keeps tracking the on-chain challenge information, and then initiates an off-chain data availability detect.</li><li>The validator uses its BLS private key to sign a data challenge vote according to the result, the vote data should be the same for all validators to sign, it should include block header, data challenge information, and the challenge result.</li><li>The validator keeps collecting data challenge votes, aggregates the signatures, assembles data challenge attestation.</li><li>The validator submits the attestation when there are more than 2/3 validators that have reached an agreement.</li><li>The data challenge attestation transaction will be executed, verify the attestation, clean the data challenge storage, slash the malicious SP, distribute the reward, and set a cooling-off period for successful data challenges to avoid attacking.</li><li>The cooling-off period is set for the validator to regain, recover, or shift this piece of data, once the cooling off period time expires, this data availability can be challenged again, if this piece of data is still unavailable, the validator would be slashed again.</li></ol><div align="center"><img src="https://raw.githubusercontent.com/bnb-chain/greenfield-whitepaper/main/assets/19.2 Data Availability Challenge.jpg" height="80%" width="80%"></div><div align="center"><i>Data Availability Challenge Workflow</i></div><h2 id="create-challenge" tabindex="-1"><a class="header-anchor" href="#create-challenge" aria-hidden="true">#</a> Create Challenge</h2><p>There are two ways to trigger challenges.</p><h3 id="submitted-challenges" tabindex="-1"><a class="header-anchor" href="#submitted-challenges" aria-hidden="true">#</a> Submitted Challenges</h3><p>Anyone can send <code>MsgSubmit</code> messages to trigger data availability challenges, if he/she finds that the data is not available or incorrect stored. When submitting the challenge, user can choose the segment/piece of an object to challenge or let the blockchain randomly selects a segment/piece to challenge. The submitter will be called as challenger, and will be rewarded if the challenge succeeds later.</p><h3 id="random-challenges" tabindex="-1"><a class="header-anchor" href="#random-challenges" aria-hidden="true">#</a> Random Challenges</h3><p>In each block, challenges will be automatically created, to challenge different objects which are stored on different storage providers. The count of random challenges in each block is governed, and can be changed by submitting proposals. To support randomness, a <em>RANDAO</em> mechanism is introduced in Greenfield blockchain. For more information about <em>RANDAO</em>, please refer to the following section.</p><h2 id="attest-challenge" tabindex="-1"><a class="header-anchor" href="#attest-challenge" aria-hidden="true">#</a> Attest Challenge</h2><p>Each validator will listen to the events of challenge creations, and vote the challenge by using its own BLS key. When there are more than 2/3 votes are collected, an attestation message <code>MsgAttest</code> will be submitted to slash the challenged storage provider. And the voted validators, the attestation submitter, and the challenger (if there is) will be rewarded accordingly.</p><h2 id="challenge-heartbeat" tabindex="-1"><a class="header-anchor" href="#challenge-heartbeat" aria-hidden="true">#</a> Challenge Heartbeat</h2><p>To indicate the off-chain challenge detect module is running correctly, validators have to vote and submit <code>MsgHeartbeat</code> messages periodically to the blockchain. During processing this kind of messages, the income for securing stored objects will be transferred from payment account to distribution account, and income can be withdrawn by validators and their delegators later.</p><h2 id="challenge-events" tabindex="-1"><a class="header-anchor" href="#challenge-events" aria-hidden="true">#</a> Challenge Events</h2>',20),c={href:"https://github.com/bnb-chain/greenfield/blob/master/proto/greenfield/challenge/events.proto",target:"_blank",rel:"noopener noreferrer"},g=t('<h3 id="start-event" tabindex="-1"><a class="header-anchor" href="#start-event" aria-hidden="true">#</a> Start Event</h3><p>This kind of events indicates that a data availability challenge is triggered on-chain. The off-chain module should monitor the events, asking the according storage prover for data, compute hashes and do the comparison, and submit an attestation if needed.</p><h3 id="complete-event" tabindex="-1"><a class="header-anchor" href="#complete-event" aria-hidden="true">#</a> Complete Event</h3><p>When an attestation is received and accepted, then this kind of events will be emitted. In the events, the slash and rewards amounts are also recorded.</p><h3 id="heartbeat-event" tabindex="-1"><a class="header-anchor" href="#heartbeat-event" aria-hidden="true">#</a> Heartbeat Event</h3><p>Heartbeat only includes the necessary information for liveness-check purpose.</p><h2 id="randao" tabindex="-1"><a class="header-anchor" href="#randao" aria-hidden="true">#</a> RANDAO</h2>',7),b={href:"https://eth2book.info/altair/part2/building_blocks/randomness",target:"_blank",rel:"noopener noreferrer"},p=t("<p>When proposing a new block, the proposer, i.e. a validator, needs to sign the current block number to get a <code>randao reveal</code>, and mixes the reveal into randao result <code>randao mix</code> by using <code>xor</code> operation. The other validators will verify the <code>randao reveal</code> and <code>randao mix</code> by following steps:</p><ol><li>The signature is verified using the proposer&#39;s public key. It means that the proposer has almost no choice about what it contributes to the RANDAO. It either contributes the correct signature over the block number, or it gives up the right for proposing the current block. If the validator does propose the current block, it still cannot predict the reveal from other validators, and even be slashed for stopping proposing blocks.</li><li>The <code>randao mix</code> is correctly updated by using <code>xor</code> operation.</li></ol><p>The implementation is conducted in Tendermint layer - a new field called <code>randao_mix</code> is added into block header. Greenfield blockchain then uses the field as a seed to randomly pick objects and storage providers to challenge in each block.</p>",3);function f(m,u){const i=h("ExternalLinkIcon");return l(),r("div",null,[d,a("p",null,[e("The following events are introduced for data availability challenge. For the detailed definition, please refer to "),a("a",c,[e("this"),o(i)]),e(".")]),g,a("p",null,[e("To support random challenges, a RANDAO mechanism is introduced like the following. Overall, the idea is very similar to the RANDAO in Ethereum beacon chain, you can refer to "),a("a",b,[e("here"),o(i)]),e(" for more information.")]),p])}const w=n(s,[["render",f],["__file","data-availability-challenge.html.vue"]]);export{w as default};

import{_ as d,W as r,X as l,Y as t,Z as e,$ as o,a0 as s,a1 as i,C as c}from"./framework-a045178c.js";const h={},u=t("h1",{id:"transaction-lifecycle",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#transaction-lifecycle","aria-hidden":"true"},"#"),e(" Transaction Lifecycle")],-1),p={href:"https://github.com/bnb-chain/greenfield-cosmos-sdk/blob/master/docs/core/transactions.md",target:"_blank",rel:"noopener noreferrer"},m=t("code",null,"Tx",-1),f=t("h2",{id:"creation",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#creation","aria-hidden":"true"},"#"),e(" Creation")],-1),g=t("h3",{id:"transaction-creation",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#transaction-creation","aria-hidden":"true"},"#"),e(" Transaction Creation")],-1),v=t("code",null,"Tx",-1),b=t("code",null,"[command]",-1),x=t("code",null,"[args]",-1),k=t("code",null,"[flags]",-1),y=i(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gnfd tx <span class="token punctuation">[</span>command<span class="token punctuation">]</span> <span class="token punctuation">[</span>args<span class="token punctuation">]</span> <span class="token punctuation">[</span>flags<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>This command will automatically <strong>create</strong> the transaction, <strong>sign</strong> it using the account&#39;s private key, and <strong>broadcast</strong> it to the specified peer node.</p>`,2),_=t("code",null,"--from",-1),T=t("code",null,"from",-1),w=t("h4",{id:"gas-and-fees",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#gas-and-fees","aria-hidden":"true"},"#"),e(" Gas and Fees")],-1),C=t("code",null,"--gas",-1),B=t("code",null,"auto",-1),A=t("code",null,"--gas",-1),I=t("li",null,[t("code",null,"--gas-prices"),e(" specifies how much the user is willing to pay per unit of gas, which can be one or multiple denominations of tokens. For example, "),t("code",null,"--gas-prices=5000000000BNB"),e(" means the user is willing to pay 5Gwei BNB per unit of gas.")],-1),M=t("li",null,[t("code",null,"--fees"),e(" specifies how much in fees the user is willing to pay in total.")],-1),D=t("li",null,[t("code",null,"--timeout-height"),e(" specifies a block timeout height to prevent the tx from being committed past a certain height.")],-1),S=i(`<p>The ultimate value of the fees paid is equal to the gas multiplied by the gas prices. In other words, <code>fees = ceil(gas * gasPrices)</code>. Thus, since fees can be calculated using gas prices and vice versa, the users specify only one of the two.</p><p>Later, validators decide whether to include the transaction in their block by comparing the given or calculated <code>gas-prices</code> to their local <code>min-gas-prices</code>. <code>Tx</code> will be rejected if its <code>gas-prices</code> is not high enough, so users are incentive to pay more.</p><h4 id="cli-example" tabindex="-1"><a class="header-anchor" href="#cli-example" aria-hidden="true">#</a> CLI Example</h4><p>Users of the application <code>app</code> can enter the following command into their CLI to generate a transaction to send 1000wei BNB from a <code>senderAddress</code> to a <code>recipientAddress</code>.</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gnfd tx send <span class="token operator">&lt;</span>recipientAddress<span class="token operator">&gt;</span> 1000BNB <span class="token parameter variable">--from</span> <span class="token operator">&lt;</span>senderAddress<span class="token operator">&gt;</span> <span class="token parameter variable">--gas</span> auto
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="other-transaction-creation-methods" tabindex="-1"><a class="header-anchor" href="#other-transaction-creation-methods" aria-hidden="true">#</a> Other Transaction Creation Methods</h4>`,6),G=t("code",null,"Tx",-1),N=t("code",null,"Tx",-1),V={href:"https://lunie.io/#/",target:"_blank",rel:"noopener noreferrer"},q=t("h2",{id:"addition-to-mempool",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#addition-to-mempool","aria-hidden":"true"},"#"),e(" Addition to Mempool")],-1),E=t("code",null,"Tx",-1),L={href:"https://docs.tendermint.com/master/spec/abci/abci.html#messages",target:"_blank",rel:"noopener noreferrer"},F=t("code",null,"CheckTx",-1),H=t("code",null,"abci.ResponseCheckTx",-1),P=t("code",null,"Tx",-1),R={href:"https://docs.tendermint.com/master/tendermint-core/mempool/",target:"_blank",rel:"noopener noreferrer"},W=t("strong",null,"Mempool",-1),z=t("code",null,"Tx",-1),j=i('<h3 id="types-of-checks" tabindex="-1"><a class="header-anchor" href="#types-of-checks" aria-hidden="true">#</a> Types of Checks</h3><p>The full-nodes perform stateless, then stateful checks on <code>Tx</code> during <code>CheckTx</code>, with the goal to identify and reject an invalid transaction as early on as possible to avoid wasted computation.</p><p><strong><em>Stateless</em></strong> checks do not require nodes to access state - light clients or offline nodes can do them - and are thus less computationally expensive. Stateless checks include making sure addresses are not empty, enforcing non-negative numbers, and other logic specified in the definitions.</p><p><strong><em>Stateful</em></strong> checks validate transactions and messages based on a committed state. Examples include checking that the relevant values exist and can be transacted with, the address has sufficient funds, and the sender is authorized or has the correct ownership to transact. At any given moment, full-nodes typically have multiple versions of the application&#39;s internal state for different purposes. For example, nodes will execute state changes while in the process of verifying transactions, but still need a copy of the last committed state in order to answer queries - they should not respond using state with uncommitted changes.</p><p>In order to verify a <code>Tx</code>, full-nodes call <code>CheckTx</code>, which includes both <em>stateless</em> and <em>stateful</em> checks. Further validation happens later in the <a href="#delivertx"><code>DeliverTx</code></a> stage. <code>CheckTx</code> goes through several steps, beginning with decoding <code>Tx</code>.</p><h3 id="decoding" tabindex="-1"><a class="header-anchor" href="#decoding" aria-hidden="true">#</a> Decoding</h3><p>When <code>Tx</code> is received by the application from the underlying consensus engine (e.g. Tendermint), it is still in its encoded <code>[]byte</code> form and needs to be unmarshaled in order to be processed. Then, the <code>runTx</code> function is called to run in <code>runTxModeCheck</code> mode, meaning the function will run all checks but exit before executing messages and writing state changes.</p><h3 id="validatebasic" tabindex="-1"><a class="header-anchor" href="#validatebasic" aria-hidden="true">#</a> ValidateBasic</h3><p>Messages <code>sdk.Msg</code> are extracted from transactions (<code>Tx</code>). The <code>ValidateBasic</code> method of the <code>sdk.Msg</code> interface implemented by the module developer is run for each transaction. To discard obviously invalid messages, the <code>BaseApp</code> type calls the <code>ValidateBasic</code> method very early in the processing of the message in the <code>CheckTx</code> and <code>DeliverTx</code> transactions. <code>ValidateBasic</code> can include only <strong>stateless</strong> checks (the checks that do not require access to the state).</p><h3 id="antehandler" tabindex="-1"><a class="header-anchor" href="#antehandler" aria-hidden="true">#</a> AnteHandler</h3><p>After the ValidateBasic checks, the <code>AnteHandler</code>s are run. Technically, they are optional, but in practice, they are very often present to perform signature verification, gas calculation, fee deduction and other core operations related to blockchain transactions.</p><p>A copy of the cached context is provided to the <code>AnteHandler</code>, which performs limited checks specified for the transaction type. Using a copy allows the <code>AnteHandler</code> to do stateful checks for <code>Tx</code> without modifying the last committed state, and revert to the original if the execution fails.</p><h3 id="gas" tabindex="-1"><a class="header-anchor" href="#gas" aria-hidden="true">#</a> Gas</h3><p>The <code>Context</code>, which keeps a <code>GasMeter</code> that will track how much gas has been used during the execution of <code>Tx</code>, is initialized. The user-provided amount of gas for <code>Tx</code> is known as <code>GasWanted</code>. If <code>GasConsumed</code>, the amount of gas consumed so during execution, ever exceeds <code>GasWanted</code>, the execution will stop and the changes made to the cached copy of the state won&#39;t be committed. Otherwise, <code>CheckTx</code> sets <code>GasUsed</code> equal to <code>GasConsumed</code> and returns it in the result. After calculating the gas and fee values, validator-nodes check that the user-specified <code>gas-prices</code> is greater than their locally defined <code>min-gas-prices</code>.</p><h3 id="discard-or-addition-to-mempool" tabindex="-1"><a class="header-anchor" href="#discard-or-addition-to-mempool" aria-hidden="true">#</a> Discard or Addition to Mempool</h3><p>If at any point during <code>CheckTx</code> the <code>Tx</code> fails, it is discarded and the transaction lifecycle ends there. Otherwise, if it passes <code>CheckTx</code> successfully, the default protocol is to relay it to peer nodes and add it to the Mempool so that the <code>Tx</code> becomes a candidate to be included in the next block.</p><p>The <strong>mempool</strong> serves the purpose of keeping track of transactions seen by all full-nodes. Full-nodes keep a <strong>mempool cache</strong> of the last <code>mempool.cache_size</code> transactions they have seen, as a first line of defense to prevent replay attacks. Ideally, <code>mempool.cache_size</code> is large enough to encompass all the transactions in the full mempool. If the mempool cache is too small to keep track of all the transactions, <code>CheckTx</code> is responsible for identifying and rejecting replayed transactions.</p><p>Currently existing preventative measures include fees and a <code>sequence</code> (nonce) counter to distinguish replayed transactions from identical but valid ones. If an attacker tries to spam nodes with many copies of a <code>Tx</code>, full-nodes keeping a mempool cache will reject identical copies instead of running <code>CheckTx</code> on all of them. Even if the copies have incremented <code>sequence</code> numbers, attackers are disincentivized by the need to pay fees.</p><p>Validator nodes keep a mempool to prevent replay attacks, just as full-nodes do, but also use it as a pool of unconfirmed transactions in preparation of block inclusion. Note that even if a <code>Tx</code> passes all checks at this stage, it is still possible to be found invalid later on, because <code>CheckTx</code> does not fully validate the transaction (i.e. it does not actually execute the messages).</p><h2 id="inclusion-in-a-block" tabindex="-1"><a class="header-anchor" href="#inclusion-in-a-block" aria-hidden="true">#</a> Inclusion in a Block</h2>',20),O=t("strong",null,"rounds",-1),U=t("strong",null,"validators",-1),X=t("code",null,"nil",-1),Y={href:"https://docs.tendermint.com/master/spec/consensus/consensus.html#terms",target:"_blank",rel:"noopener noreferrer"},Z=i(`<p>The first step of consensus is the <strong>block proposal</strong>. One proposer amongst the validators is chosen by the consensus algorithm to create and propose a block - in order for a <code>Tx</code> to be included, it must be in this proposer&#39;s mempool.</p><h2 id="state-changes" tabindex="-1"><a class="header-anchor" href="#state-changes" aria-hidden="true">#</a> State Changes</h2><p>The next step of consensus is to execute the transactions to fully validate them. All full-nodes that receive a block proposal from the correct proposer execute the transactions by calling the ABCI functions <code>BeginBlock</code>, <code>DeliverTx</code> for each transaction, and <code>EndBlock</code>. While each full-node runs everything locally, this process yields a single, unambiguous result, since the messages&#39; state transitions are deterministic and transactions are explicitly ordered in the block proposal.</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>		-----------------------
		|Receive Block Proposal|
		-----------------------
		          |
			  v
		-----------------------
		| BeginBlock	      |
		-----------------------
		          |
			  v
		-----------------------
		| DeliverTx(tx0)      |
		| DeliverTx(tx1)      |
		| DeliverTx(tx2)      |
		| DeliverTx(tx3)      |
		|	.	      |
		|	.	      |
		|	.	      |
		-----------------------
		          |
			  v
		-----------------------
		| EndBlock	      |
		-----------------------
		          |
			  v
		-----------------------
		| Consensus	      |
		-----------------------
		          |
			  v
		-----------------------
		| Commit	      |
		-----------------------
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="delivertx" tabindex="-1"><a class="header-anchor" href="#delivertx" aria-hidden="true">#</a> DeliverTx</h3><p>The <code>DeliverTx</code> ABCI function defined in <code>BaseApp</code> does the bulk of the state transitions: it is run for each transaction in the block in sequential order as committed to during consensus. Under the hood, <code>DeliverTx</code> is almost identical to <code>CheckTx</code> but calls the <code>runTx</code> function in deliver mode instead of check mode. Instead of using their <code>checkState</code>, full-nodes use <code>deliverState</code>:</p><ul><li><p><strong>Decoding:</strong> Since <code>DeliverTx</code> is an ABCI call, <code>Tx</code> is received in the encoded <code>[]byte</code> form. Nodes first unmarshal the transaction, using the <code>TxConfig</code> defined in the app, then call <code>runTx</code> in <code>runTxModeDeliver</code>, which is very similar to <code>CheckTx</code> but also executes and writes state changes.</p></li><li><p><strong>Checks and AnteHandler:</strong> Full-nodes call <code>validateBasicMsgs</code> and <code>AnteHandler</code> again. This second check happens because they may not have seen the same transactions during the addition to Mempool stage and a malicious proposer may have included invalid ones. One difference here is that the <code>AnteHandler</code> will not compare <code>gas-prices</code> to the node&#39;s <code>min-gas-prices</code> since that value is local to each node - differing values across nodes would yield nondeterministic results.</p></li><li><p><strong><code>MsgServiceRouter</code>:</strong> While <code>CheckTx</code> would have exited, <code>DeliverTx</code> continues to run <code>runMsgs</code> to fully execute each <code>Msg</code> within the transaction. Since the transaction may have messages from different modules, <code>BaseApp</code> needs to know which module to find the appropriate handler. This is achieved using <code>BaseApp</code>&#39;s <code>MsgServiceRouter</code> so that it can be processed by the module&#39;s Protobuf <code>Msg</code> service.</p></li><li><p><strong><code>Msg</code> service:</strong> Protobuf <code>Msg</code> service is responsible for executing each message in the <code>Tx</code> and causes state transitions to persist in <code>deliverTxState</code>.</p></li><li><p><strong>PostHandlers:</strong> <code>PostHandler</code>s run after the execution of the message. If they fail, the state change of <code>runMsgs</code>, as well of <code>PostHandlers</code> are both reverted.</p></li><li><p><strong>Gas:</strong> While a <code>Tx</code> is being delivered, a <code>GasMeter</code> is used to keep track of how much gas is being used; if execution completes, <code>GasUsed</code> is set and returned to the <code>abci.ResponseDeliverTx</code>. If execution halts because <code>BlockGasMeter</code> or <code>GasMeter</code> has run out or something else goes wrong, a deferred function at the end appropriately errors or panics.</p></li></ul><p>If there are any failed state changes resulting from a <code>Tx</code> being invalid or <code>GasMeter</code> running out, the transaction processing terminates and any state changes are reverted. Invalid transactions in a block proposal cause validator nodes to reject the block and vote for a <code>nil</code> block instead.</p><h3 id="commit" tabindex="-1"><a class="header-anchor" href="#commit" aria-hidden="true">#</a> Commit</h3><p>The final step is for nodes to commit the block and state changes. Validator nodes perform the previous step of executing state transitions in order to validate the transactions, then sign the block to confirm it. Full nodes that are not validators do not participate in consensus - i.e. they cannot vote - but listen for votes to understand whether they should commit the state changes.</p><p>When they receive enough validator votes (2/3+ <em>precommits</em> weighted by voting power), full nodes commit to a new block to be added to the blockchain and finalize the state transitions in the application layer. A new state root is generated to serve as a merkle proof for the state transitions. Applications use the <code>Commit</code> ABCI method inherited from Baseapp; it syncs all the state transitions by writing the <code>deliverState</code> into the application&#39;s internal state. As soon as the state changes are committed, <code>checkState</code> start afresh from the most recently committed state and <code>deliverState</code> resets to <code>nil</code> in order to be consistent and reflect the changes.</p><p>Note that not all blocks have the same number of transactions, and it is possible for consensus to result in a <code>nil</code> block or one with none at all. In a public blockchain network, it is also possible for validators to be <strong>byzantine</strong>, or malicious, which may prevent a <code>Tx</code> from being committed in the blockchain. Possible malicious behaviors include the proposer deciding to censor a <code>Tx</code> by excluding it from the block or a validator voting against the block.</p><p>At this point, the transaction lifecycle of a <code>Tx</code> is over: nodes have verified its validity, delivered it by executing its state changes, and committed those changes. The <code>Tx</code> itself, in <code>[]byte</code> form, is stored in a block and appended to the blockchain.</p>`,13);function $(J,K){const a=c("ExternalLinkIcon"),n=c("RouterLink");return r(),l("div",null,[u,t("p",null,[e("This document describes the lifecycle of a transaction from creation to committed state changes. Transaction definition is described in a "),t("a",p,[e("different doc"),o(a)]),e(". The transaction will be referred to as "),m,e(".")]),f,g,t("p",null,[e("One of the main application interfaces is the command-line interface. The transaction "),v,e(" can be created by the user inputting a command in the following format from the "),o(n,{to:"/docs/greenfield-blockchain/cli/"},{default:s(()=>[e("command-line")]),_:1}),e(", providing the type of transaction in "),b,e(", arguments in "),x,e(", and configurations such as gas prices in "),k,e(":")]),y,t("p",null,[e("There are several required and optional flags for transaction creation. The "),_,e(" flag specifies which "),o(n,{to:"/docs/greenfield-blockchain/core-concept/accounts.html"},{default:s(()=>[e("account")]),_:1}),e(" the transaction is originating from. For example, if the transaction is sending coins, the funds will be drawn from the specified "),T,e(" address.")]),w,t("p",null,[e("Additionally, there are several "),o(n,{to:"/docs/greenfield-blockchain/cli/"},{default:s(()=>[e("flags")]),_:1}),e(" users can use to indicate how much they are willing to pay in "),o(n,{to:"/docs/greenfield-blockchain/core-concept/gas-fees.html"},{default:s(()=>[e("fees")]),_:1}),e(":")]),t("ul",null,[t("li",null,[C,e(" refers to how much "),o(n,{to:"/docs/greenfield-blockchain/core-concept/gas-fees.html"},{default:s(()=>[e("gas")]),_:1}),e(". Different from other cosmos blockchain where gas represents computational resources, on greenfield blockchain, the gas of a transaction is predefined. It is suggested to be estimated by providing "),B,e(" as the value for "),A,e(".")]),I,M,D]),S,t("p",null,[e("The command-line is an easy way to interact with an application, but "),G,e(" can also be created using a "),o(n,{to:"/docs/api-sdk/grpc_rest.html"},{default:s(()=>[e("gRPC or REST interface")]),_:1}),e(" or some other entry point defined by the application developer. From the user's perspective, the interaction depends on the web interface or wallet they are using (e.g. creating "),N,e(" using "),t("a",V,[e("Lunie.io"),o(a)]),e(" and signing it with a Ledger Nano S).")]),q,t("p",null,[e("Each full-node (running Tendermint) that receives a "),E,e(" sends an "),t("a",L,[e("ABCI message"),o(a)]),e(", "),F,e(", to the application layer to check for validity, and receives an "),H,e(". If the "),P,e(" passes the checks, it is held in the nodes'"),t("a",R,[W,o(a)]),e(", an in-memory pool of transactions unique to each node, pending inclusion in a block - honest nodes will discard "),z,e(" if it is found to be invalid. Prior to consensus, nodes continuously check incoming transactions and gossip them to their peers.")]),j,t("p",null,[e("Consensus, the process through which validator nodes come to agreement on which transactions to accept, happens in "),O,e(". Each round begins with a proposer creating a block of the most recent transactions and ends with "),U,e(", special full-nodes with voting power responsible for consensus, agreeing to accept the block or go with a "),X,e(" block instead. Validator nodes execute the consensus algorithm, such as "),t("a",Y,[e("Tendermint BFT"),o(a)]),e(", confirming the transactions using ABCI requests to the application, in order to come to this agreement.")]),Z])}const ee=d(h,[["render",$],["__file","transaction-lifecycle.html.vue"]]);export{ee as default};
